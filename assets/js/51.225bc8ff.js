(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{484:function(e,t,r){"use strict";r.r(t);var n=r(1),o=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[e._v("#")]),e._v(" 概念")]),e._v(" "),t("p",[e._v("node.js 就是一个 js 的运行环境，构建在 V8 引擎之上。（服务器）\n作用就是让 JS 可以在浏览器以外的地方运行。可以用 JS 编写服务器了，运行在服务器端的 JS\n特点：单线程，异步，非阻塞，统一 API")]),e._v(" "),t("blockquote",[t("p",[e._v("npm 是管理 Node 工作包（开发依赖）的工具\nnvm 是管理 node 本身的工具\nnode 与 JS 的区别\nJS 三大组成部分（ES 标准，DOM，BOM）\nnode 只有 ES 标准，对于 DOM 和 BOM 只保留了一些常用的部分，比如 console.log")])]),e._v(" "),t("blockquote",[t("p",[e._v("进程（工厂，运行环境）与线程（工人，操作的人）\n同步与异步，JS 是异步的，像 while 这种语法是同步的，return 也是代表了同步\n[[]]双中括号代表的属性时隐藏属性，一旦确定了之后就不能改变了")])]),e._v(" "),t("p",[e._v("JS 是异步的，所以就诞生了回调函数，回调函数来处理异步操作，所以 JS 离不开回调函数\n这就带来了 JS 中的常见问题（回调地狱），这也是异步的最大问题")]),e._v(" "),t("h3",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("解决方法：用 Promise 来代替回调函数，Promise 是一个存储数据（特殊数据）的对象，这个特殊数据就是异步调用时的数据（resolve, reject），同时要注意，无论是 resolve 还是 reject，Promise 只能修改一次，修改后的值就是该 promise 对象的值了，不能再被 resolve 和 reject 存储了。")])]),e._v(" "),t("li",[t("p",[e._v("异步函数无法使用 return 来返回，要使用回调函数来返回数据\n.then 方法就是读取 promise 中存储的数据，相当于为 Promise 设置了回调函数，\n如果 PromiseState 变为 fulfilled，则调用 then 的第一个回调函数来返回数据\n如果 PromiseState 变为 rejected，则调用 then 的第二个回调函数来返回数据\n.then 里面的代码会在主代码（调用栈中的代码）执行完之后才会执行")])])]),e._v(" "),t("p",[e._v("箭头函数中如果只有一行代码的话，那这行代码就作为函数的返回值来返回，也就是箭头直接指向了返回体。\n多个.then 连续调用具有数据穿透能力，数据可以隔着.then 传递，也就是跳过当前的方法")]),e._v(" "),t("p",[e._v("Promise 存在异常时，如果有 catch，则不会报错，没有则会抛出异常，同时，catch 只会抛出它前边的 error，如果 catch 后面还有错，那前边的 catch 就没用了，所以通常把 catch 写到函数的最后")]),e._v(" "),t("p",[e._v("Promise 是异步的（任务队列），console.log 执行的往往最快")]),e._v(" "),t("h3",{attrs:{id:"执行顺序问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行顺序问题"}},[e._v("#")]),e._v(" 执行顺序问题")]),e._v(" "),t("p",[e._v("JS 的运行机制是事件循环机制（event loop）\n调用栈中是正在执行的代码（要执行的）\n消息队列（任务队列）中是要等栈里边空了之后才会进入调用栈的代码（待命），setTimeout 中的代码是放入宏任务中的，全局作用域中的代码块直接就是放在调用栈中的。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("JS 中有两种任务队列（宏任务和微任务），其中，大部分代码都是宏任务，Promise 代码是在微任务中")])]),e._v(" "),t("li",[t("p",[e._v("JS 中的代码运行顺序从前到后可以理解为，栈 → tick 队列 → 微任务 → 宏任务")])])])])}),[],!1,null,null,null);t.default=o.exports}}]);