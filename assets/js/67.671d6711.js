(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{497:function(v,_,e){"use strict";e.r(_);var t=e(1),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"v-if"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v-if"}},[v._v("#")]),v._v(" v-if")]),v._v(" "),_("p",[_("code",[v._v("v-show")]),v._v(" 可以根据值来决定元素是否显示（通过"),_("code",[v._v("display")]),v._v("来切换元素的显示状态）")]),v._v(" "),_("p",[_("code",[v._v("v-if")]),v._v(" 可以根据表达式的值来决定是否显示元素（会直接将元素删除）\n"),_("strong",[v._v("区别")])]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("v-show")]),v._v("通过"),_("code",[v._v("css")]),v._v("来切换组件的显示与否，切换时不会涉及到组件的重新渲染\n切换的性能比较高。但是初始化时，需要对所有组件进行初始化（即使组件暂时不显示）\n所以它的初始化的性能要差一些")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("v-if")]),v._v("通过删除添加元素的方式来切换元素的显示，切换时反复的渲染组件，切换的性能比较差。\n"),_("code",[v._v("v-if")]),v._v("只会初始化需要用到的组件，所以它的初始化性能比较好")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("v-if")]),v._v("可以和 "),_("code",[v._v("v-else-if")]),v._v(" 和 "),_("code",[v._v("v-else")]),v._v(" 结合使用，还可以配合"),_("code",[v._v("template")]),v._v("使用")])])]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("v-if")]),v._v(" 和"),_("code",[v._v("v-show")]),v._v(" 都会触发重排和重绘，性能区别是组件渲染的区别，怎么使用组件决定了谁的性能更优"),_("br"),v._v(" "),_("code",[v._v("v-show")]),v._v(" 切换速度快，"),_("code",[v._v("v-if")]),v._v(" 加载速度快")])]),v._v(" "),_("h2",{attrs:{id:"v-for"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v-for"}},[v._v("#")]),v._v(" v-for")]),v._v(" "),_("p",[_("code",[v._v("v-for")]),v._v("写在谁上边，就重复生成谁")]),v._v(" "),_("p",[v._v("重复执行用到"),_("code",[v._v("v-for")]),v._v("的组件，数组有多少元素就执行几次")]),v._v(" "),_("p",[v._v("值在前，索引在后")]),v._v(" "),_("p",[v._v("我们在使用"),_("code",[v._v("v-for")]),v._v("遍历时，旧的结构和新的结构是按照顺序进行对比的——默认是顺序比较")]),v._v(" "),_("p",[v._v("在使用"),_("code",[v._v("v-for")]),v._v("时，可以为元素指定一个唯一的"),_("code",[v._v("key")]),v._v("，有了"),_("code",[v._v("key")]),v._v("以后，元素再比较时就会按照相同的"),_("code",[v._v("key")]),v._v("去比较而不是顺序")]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("key")]),v._v("尽量设置为"),_("code",[v._v("id")]),v._v("，不要设置为"),_("code",[v._v("index")]),v._v("，因为"),_("code",[v._v("index")]),v._v("默认也是顺序排列，所以加上"),_("code",[v._v("index")]),v._v("跟原来的效果一样")])]),v._v(" "),_("p",[v._v("当"),_("code",[v._v("v-if")]),v._v(" 和"),_("code",[v._v("v-for")]),v._v(" 同时存在同一个节点上时，"),_("code",[v._v("v-if")]),v._v(" 比 "),_("code",[v._v("v-for")]),v._v(" 的优先级更高，这意味着 v-if 无法访问到 v-for 中的变量别名")]),v._v(" "),_("h2",{attrs:{id:"动态组件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#动态组件"}},[v._v("#")]),v._v(" 动态组件")]),v._v(" "),_("p",[_("code",[v._v("component")]),v._v(" 是一个动态组件")]),v._v(" "),_("div",{staticClass:"language-javascript extra-class"},[_("pre",{pre:!0,attrs:{class:"language-javascript"}},[_("code",[_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("component is"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"div"')]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("/")]),v._v("component"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v("\n")])])]),_("p",[_("code",[v._v("component")]),v._v("最终以什么标签呈现由"),_("code",[v._v("is")]),v._v("属性决定")]),v._v(" "),_("h2",{attrs:{id:"网页渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网页渲染"}},[v._v("#")]),v._v(" 网页渲染")]),v._v(" "),_("ul",[_("li",[v._v("浏览器在渲染页面时，做了什么")])]),v._v(" "),_("ol",[_("li",[v._v("加载页面的"),_("code",[v._v("html")]),v._v("和"),_("code",[v._v("css")]),v._v("（源码）")]),v._v(" "),_("li",[_("code",[v._v("html")]),v._v("转换为"),_("code",[v._v("DOM")]),v._v("，css 转换为 CSSOM")]),v._v(" "),_("li",[v._v("将"),_("code",[v._v("DOM")]),v._v("和"),_("code",[v._v("CSSOM")]),v._v("构建成一课渲染树")]),v._v(" "),_("li",[v._v("对渲染树进行"),_("code",[v._v("reflow")]),v._v("（回流、重排）（计算元素的位置）")]),v._v(" "),_("li",[v._v("对网页进行绘制"),_("code",[v._v("repaint")]),v._v("（重绘）")])]),v._v(" "),_("h3",{attrs:{id:"渲染树-render-tree"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染树-render-tree"}},[v._v("#")]),v._v(" 渲染树（Render Tree）")]),v._v(" "),_("ul",[_("li",[v._v("从根元素开始检查那些元素可见，以及他们的样式")]),v._v(" "),_("li",[v._v("忽略那些不可见的元素（"),_("code",[v._v("display:none")]),v._v("）—— 但样式为 "),_("code",[v._v("visibility: hidden")]),v._v(" 的元素会被渲染，因为元素是被隐藏，所以要在渲染树的结构中")])]),v._v(" "),_("h3",{attrs:{id:"重排、回流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重排、回流"}},[v._v("#")]),v._v(" 重排、回流")]),v._v(" "),_("ul",[_("li",[v._v("计算渲染树中元素的大小和位置")]),v._v(" "),_("li",[v._v("当页面中的元素的大小或位置发生变化时，便会触发页面的重排（回流）\n"),_("blockquote",[_("p",[v._v("注意：每次修改这类样式 （"),_("code",[v._v("width")]),v._v("、"),_("code",[v._v("height")]),v._v("、"),_("code",[v._v("margin")]),v._v("、"),_("code",[v._v("font-size")]),v._v(" ......）都会触发一次重排，所以如果分次修改多个样式会触发重排多次，而重排是非常耗费系统资源的操作（昂贵），重排次数过多后，会导致网页的显示性能变差，在开发时我们应该尽量的减少重排的次数")])])]),v._v(" "),_("li",[v._v("在现代的前端框架中，这些东西都已经被框架优化过了，所以使用 vue、react 这些框架这些框架开发时，几乎不需要考虑这些问题，唯独需要注意的时，尽量减少在框架中直接操作 DOM")])]),v._v(" "),_("h3",{attrs:{id:"重绘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[v._v("#")]),v._v(" 重绘")]),v._v(" "),_("ul",[_("li",[v._v("绘制页面")]),v._v(" "),_("li",[v._v("当页面发生变化时，浏览器就会对页面进行重新的绘制")])]),v._v(" "),_("blockquote",[_("p",[v._v("重排一定会导致重绘，重绘不一定会导致重排\n重绘是不可避免的，所以在开发时应减少重排")])]),v._v(" "),_("h2",{attrs:{id:"杂"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#杂"}},[v._v("#")]),v._v(" 杂")]),v._v(" "),_("p",[v._v("数据的简单绑定—— "),_("code",[v._v("Mustache")]),v._v("语法（双大括号）—— 渲染"),_("code",[v._v("data")])]),v._v(" "),_("p",[v._v("后代选择器性能比较差，不是开发中常用的，不如给元素写一个单独的"),_("code",[v._v("class")])]),v._v(" "),_("div",{staticClass:"language-javascript extra-class"},[_("pre",{pre:!0,attrs:{class:"language-javascript"}},[_("code",[v._v("photo img"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 修改为")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("photo"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("img"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])]),_("ul",[_("li",[_("code",[v._v("in")]),v._v(" 在原生"),_("code",[v._v("JS")]),v._v("里是取对象的属性名")]),v._v(" "),_("li",[_("code",[v._v("of")]),v._v(" 一般用来遍历数组\n尽可能减少根组件的逻辑")])]),v._v(" "),_("p",[v._v("面向对象——单一职责——一个组件只做一件事")])])}),[],!1,null,null,null);_.default=a.exports}}]);