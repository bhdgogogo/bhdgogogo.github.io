(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{502:function(t,a,v){"use strict";v.r(a);var e=v(1),s=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("插值语法一般不应用于在标签上动态绑定数据 —— 比如url中的引号属性")]),t._v(" "),a("p",[t._v("插值语法一般用于解析标签体内容 —— "),a("code",[t._v("<div>"+t._s(t.xxx)+"</div>")])]),t._v(" "),a("p",[t._v("指令语法一般用于解析标签\n"),a("code",[t._v('v-bind:href = "url"')]),t._v(" —— "),a("code",[t._v("vue")]),t._v("就会帮我们把引号中的内容看作是JS表达式")]),t._v(" "),a("p",[t._v("模板"),a("code",[t._v("{{}}")]),t._v("中都能写什么？—— vue实例对象中的所有属性都可以写（data中的内容vue就会把它们放到vue实例对象中，就是vue实例对象的属性）—— vue原型上的所有属性也都可以直接写")]),t._v(" "),a("p",[t._v("数据代理： 通过一个对象代理对另一个对象中属性的操作（读./写）")]),t._v(" "),a("p",[t._v("options就是配置对象")]),t._v(" "),a("p",[t._v("测试一下vm.data能不能读出来\nvm中的getter和setter")]),t._v(" "),a("p",[a("code",[t._v("_data")]),t._v("是数据监视 —— 只有监视到数据发生了改变，才能同时响应地改变view中的数据，实现响应式代理\n它本质上就是data —— 但是进行了一点小小的升级 —— reactive")]),t._v(" "),a("p",[a("code",[t._v("vm.name")]),t._v("读取的其实就是"),a("code",[t._v("vm._data.name")]),t._v("的内容")]),t._v(" "),a("p",[t._v("数据代理干了什么？ —— 把"),a("code",[t._v("_data")]),t._v("中的数据放到vm中一份，在执行"),a("code",[t._v("vm.name时")]),t._v("，其实就是执行了"),a("code",[t._v("vm.get()")]),t._v("，从而读取到了"),a("code",[t._v("_data")]),t._v("中的"),a("code",[t._v("name")]),t._v("，执行"),a("code",[t._v('vm.name = "xxx"')]),t._v("时，其实就是执行了"),a("code",[t._v("set")]),t._v("，从而修改了"),a("code",[t._v("_data")]),t._v("中的"),a("code",[t._v("name")]),t._v("，这是为了便于代码的编写")]),t._v(" "),a("p",[a("code",[t._v("vue2")]),t._v("是使用了"),a("code",[t._v("Object.defineProperty")]),t._v("这个"),a("code",[t._v("API")]),t._v("来实现了数据代理")]),t._v(" "),a("p",[t._v("$event作为参数传给自定义函数，可以获取到触发该事件的event对象")]),t._v(" "),a("p",[t._v("Vue中的事件修饰符：")]),t._v(" "),a("ol",[a("li",[t._v("prevent：阻止默认事件（常用）；")]),t._v(" "),a("li",[t._v("stop：阻止事件冒泡（常用）；")]),t._v(" "),a("li",[t._v("once：事件只触发一次（常用）；")]),t._v(" "),a("li",[t._v("capture：使用事件的捕获模式 —— 捕获阶段就开始执行事件")]),t._v(" "),a("li",[t._v("self：只有event.target是当前操作的元素时才触发事件；")])]),t._v(" "),a("p",[t._v("捕获阶段是由外往内，冒泡是从内往外")]),t._v(" "),a("p",[t._v("event.keyCode —— 按键编码")]),t._v(" "),a("p",[t._v("1.Vue中常用的按键别名：")]),t._v(" "),a("p",[t._v("回车 => enter\n删除 => delete (捕获“删除”和“退格”键)\n退出 => esc\n空格 => space\n换行 => tab (特殊，必须配合keydown去使用)\n上 => up\n下 => down\n左 => left\n右 => right")]),t._v(" "),a("p",[t._v("2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）")]),t._v(" "),a("p",[t._v("3.系统修饰键（用法特殊）：ctrl、alt、shift、meta\n(1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。\n(2).配合keydown使用：正常触发事件。")]),t._v(" "),a("p",[t._v("4.也可以使用keyCode去指定具体的按键（不推荐）")]),t._v(" "),a("p",[t._v("5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名（也不太推荐）")]),t._v(" "),a("p",[t._v("vue中的一个原则 —— 模板中应该尽量使用简单的表达式")]),t._v(" "),a("p",[t._v("只要data中的数据发生了变化，vue一定会重新解析模板")]),t._v(" "),a("p",[t._v("computed与methods实现相比，内部有缓存操作，，读取了一次vm中没有的变量后，他会进行缓存，之后再读取时，不需要再调用get，直接读取缓存中的结果，效率更高，调试方便")]),t._v(" "),a("p",[t._v("data和methods中写的东西会直接放在vm中，但是computed不是，它会把xxx的get的返回值，作为xxx放在vm中，但用起来是一样的，设置的计算属性（注意是计算属性！，虽然他里边是个函数来计算的，但是他是返回结果，然后把该结果作为vm的属性存储的）也是在vm上，直接读取使用即可")]),t._v(" "),a("p",[t._v("vue默认是能监视到多层结构属性的变化的，但是watch方法默认是不行的，需要配置deep: true")]),t._v(" "),a("h3",{attrs:{id:"watch对比computed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch对比computed"}},[t._v("#")]),t._v(" watch对比computed")]),t._v(" "),a("p",[t._v("watch也可以实现计算data的需求，但是代码要繁琐一些，还要定义新的data变量")]),t._v(" "),a("p",[t._v("watch可以实现异步任务（而且此时的异步任务一定要使用箭头函数，因为箭头函数会往外层找this，此时外层的this是vm），但computed不行，因为computed是通过返回值来处理数据的")]),t._v(" "),a("p",[t._v("两个重要的小原则：")]),t._v(" "),a("ol",[a("li",[t._v("所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。")]),t._v(" "),a("li",[t._v("所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。")])]),t._v(" "),a("h3",{attrs:{id:"绑定样式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#绑定样式"}},[t._v("#")]),t._v(" 绑定样式：")]),t._v(" "),a("ol",[a("li",[t._v('class样式\n写法:class="xxx" xxx可以是字符串、对象、数组。\n字符串写法适用于：类名不确定，要动态获取。\n对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。\n数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。')]),t._v(" "),a("li",[t._v('style样式\n:style="{fontSize: xxx}"其中xxx是动态值。\n:style="[a,b]"其中a、b是样式对象。')])]),t._v(" "),a("h3",{attrs:{id:"key的作用和原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#key的作用和原理"}},[t._v("#")]),t._v(" key的作用和原理")]),t._v(" "),a("p",[t._v("index会出问题，id可以解决")]),t._v(" "),a("p",[t._v("虚拟DOM必须是有Key的，没有Key的话vue就没办法工作了")]),t._v(" "),a("p",[t._v("遍历列表时Key的作用（Index 作为key）")]),t._v(" "),a("p",[t._v("数据 —— 根据数据生成虚拟DOM —— 将虚拟DOM转为真实DOM")]),t._v(" "),a("p",[t._v("v-for时如果没有写key，vue会默认将index作为key")]),t._v(" "),a("p",[t._v("能不能使用Index也要看场景")]),t._v(" "),a("p",[t._v("面试题：react、vue中的key有什么作用？（key的内部原理）")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("虚拟DOM中key的作用：\nkey是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,\n随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：")])]),t._v(" "),a("li",[a("p",[t._v("对比规则：\n(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：")])])]),t._v(" "),a("ul",[a("li",[t._v("若虚拟DOM中内容没变, 直接使用之前的真实DOM！")]),t._v(" "),a("li",[t._v("若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。")])]),t._v(" "),a("p",[t._v("(2).旧虚拟DOM中未找到与新虚拟DOM相同的key\n创建新的真实DOM，随后渲染到到页面。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("用index作为key可能会引发的问题：")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("若对数据进行：逆序添加、逆序删除等破坏顺序操作:"),a("br"),t._v("\n会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。")])]),t._v(" "),a("li",[a("p",[t._v("如果结构中还包含输入类的DOM：\n会产生错误DOM更新 ==> 界面有问题。")])])]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("开发中如何选择key?:\n1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。\n2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。")])]),t._v(" "),a("h3",{attrs:{id:"列表过滤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#列表过滤"}},[t._v("#")]),t._v(" 列表过滤")]),t._v(" "),a("p",[t._v('字符串中是含有空字符的，"abc".indexOf(‘ ’) = 0\n但computed和watch都能实现时，优先使用computed')]),t._v(" "),a("p",[t._v("sort是改变原数组的，filter是不改变原数组的")]),t._v(" "),a("h2",{attrs:{id:"vue监测数据改变时的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue监测数据改变时的原理"}},[t._v("#")]),t._v(" vue监测数据改变时的原理")]),t._v(" "),a("h3",{attrs:{id:"监测对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监测对象"}},[t._v("#")]),t._v(" 监测对象")]),t._v(" "),a("p",[t._v("vue检测对象中数据改变时，就是利用了setter，无论时什么类型的数据，vue都会找到，并给其设置getter和setter —— 所有的setter都做了一件事，只要你改数据，就会去重新解析模板，生成虚拟DOM和后续的工作")]),t._v(" "),a("p",[t._v("vue的一个特点—— 如果值是undefined，则不会显示到页面上")]),t._v(" "),a("h3",{attrs:{id:"vue-set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-set"}},[t._v("#")]),t._v(" Vue.set()")]),t._v(" "),a("p",[t._v("Vue.set(target, key, val) == vm.$set(target, key, val)\n用法:")]),t._v(" "),a("p",[t._v("向响应式对象中添加一个property，并确保这个新 property同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新property，因为Vue无法探测普通的新增property (比如this.my0bject.newProperty = 'hi' )")]),t._v(" "),a("p",[t._v("局限性： .set只能给data里的对象添加属性，而不能直接往data里添加属性")]),t._v(" "),a("h3",{attrs:{id:"监测数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监测数组"}},[t._v("#")]),t._v(" 监测数组")]),t._v(" "),a("p",[t._v("通过数组下标修改数组元素，vue是监测不到的，也就不会触发页面中数据的修改")]),t._v(" "),a("p",[t._v("要通过数组的方法（比如push, splice等）来修改数组数据，才能实现页面数据的响应式更新")]),t._v(" "),a("p",[t._v("原因： vue管理了数组，所以它包装了数组上的常用方法 ——  先执行数组原生的方法，然后"),a("strong",[t._v("重新解析了模板")])]),t._v(" "),a("p",[t._v("给data绑定getter和setter，就是数据劫持")]),t._v(" "),a("p",[t._v("v-model其实带有修饰符的作用，\n比如v-model.number就可以设置把输入的内容以Number形式来收集进来\n像其他的.lazy和.trim等也是可以用在v-model上的")]),t._v(" "),a("p",[t._v('type="number" 控制输入的是数字，不是数字不让输入')]),t._v(" "),a("p",[t._v(".number把输入的内容转换为Number来存储")]),t._v(" "),a("h2",{attrs:{id:"filter-过滤器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#filter-过滤器"}},[t._v("#")]),t._v(" filter 过滤器")]),t._v(" "),a("p",[t._v("与computed和methods同级")]),t._v(" "),a("p",[t._v("过滤器没有改变原数据，是产生了新数据\n“| |” —— 管道符")]),t._v(" "),a("p",[t._v("ES6 —— 形参默认值\n过滤器只能用在v-bind和插值语法中，不能用在v-model上")]),t._v(" "),a("h2",{attrs:{id:"v-html"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-html"}},[t._v("#")]),t._v(" v-html")]),t._v(" "),a("p",[t._v("v-html有安全性问题，\n在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击\n一定要在可信的内容上使用v-html，永远不要在用户提交的内容上使用")]),t._v(" "),a("h2",{attrs:{id:"directives-自定义指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#directives-自定义指令"}},[t._v("#")]),t._v(" directives —— 自定义指令")]),t._v(" "),a("p",[t._v("什么时候会调用？——")]),t._v(" "),a("ol",[a("li",[t._v("指令与元素成功绑定时（一开始）")]),t._v(" "),a("li",[t._v("指令所在的模板被重新解析时")])]),t._v(" "),a("p",[t._v("bind() —— 指令与元素成功绑定时（一开始）\ninserted() —— 指令所在元素被插入页面时\nupdate() —— 指令所在的模板被重新解析时")]),t._v(" "),a("p",[t._v("user-name —— kebab-case命名\nuserName —— camelCase命名")]),t._v(" "),a("p",[t._v("回调函数 —— 我们定义的，我们没执行，但是最终执行了")]),t._v(" "),a("h2",{attrs:{id:"vue生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[t._v("#")]),t._v(" vue生命周期")]),t._v(" "),a("p",[t._v("mounted()")]),t._v(" "),a("p",[t._v("vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕），调用mounted")]),t._v(" "),a("p",[t._v("挂载流程\n更新流程")]),t._v(" "),a("p",[t._v("只要到了beforeDestroy阶段，可以访问到数据和方法，但是对数据的修改不会再更新了")]),t._v(" "),a("p",[t._v("beforeCreate和created是创建数据监测和数据代理之前之后，不是创建vm实例")]),t._v(" "),a("h2",{attrs:{id:"组件化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件化"}},[t._v("#")]),t._v(" 组件化")]),t._v(" "),a("p",[t._v("为什么要组件化？")]),t._v(" "),a("ol",[a("li",[t._v("依赖关系混乱， 不好维护")]),t._v(" "),a("li",[t._v("代码复用率低")])]),t._v(" "),a("p",[t._v("组件的定义： 实现应用中"),a("strong",[t._v("局部")]),t._v("功能"),a("strong",[t._v("代码")]),t._v("和"),a("strong",[t._v("资源")]),t._v("的"),a("strong",[t._v("集合")])]),t._v(" "),a("p",[t._v("模块的定义")]),t._v(" "),a("p",[t._v("理解： 向外提供特定功能的js程序，一般就是一个js文件\n为什么：js文件很多很复杂\n作用：复用js，简化js的编写，提高js运行效率")]),t._v(" "),a("p",[t._v("模块化：")]),t._v(" "),a("p",[t._v("当应用中的js都以模块来编写的，那这个应用就是一个模块化的应用")]),t._v(" "),a("p",[t._v("组件化：")]),t._v(" "),a("p",[t._v("当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用")]),t._v(" "),a("p",[t._v("组件之间要调用，所以data的底层编写应该是以函数式，而不应该用对象式 —— 因为如果写成了对象式，那在一个地方修改data时，另一个用到该组件的地方的数据也会随之更改，因为他们指向了一个对象")]),t._v(" "),a("h2",{attrs:{id:"组件的几个问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件的几个问题"}},[t._v("#")]),t._v(" 组件的几个问题")]),t._v(" "),a("p",[t._v("必须使用脚手架的场景，没有使用脚手架时会出现问题")]),t._v(" "),a("ul",[a("li",[t._v("组件名定义成大写")]),t._v(" "),a("li",[t._v("自闭合标签的写法")])]),t._v(" "),a("p",[t._v("组件本质就是一个构造函数")]),t._v(" "),a("p",[t._v("每次调用Vue.extend，返回的都是一个全新的VueComponent！！！\n长的一模一样，但是两个VueComponent")]),t._v(" "),a("h2",{attrs:{id:"一个重要的内置关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一个重要的内置关系"}},[t._v("#")]),t._v(" 一个重要的内置关系")]),t._v(" "),a("p",[a("code",[t._v("xxx.prototype")]),t._v(" —— 显式原型属性\n"),a("code",[t._v("x.__protp__")]),t._v(" —— 隐式原型属性")]),t._v(" "),a("p",[t._v("显式原型属性和隐式原型属性都指向一个原型对象，只有一个原型对象")]),t._v(" "),a("p",[a("code",[t._v("Demo.prototype === d.__proto__")]),t._v("  —— true")]),t._v(" "),a("p",[t._v("对象身上一定有"),a("code",[t._v("__proto__")]),t._v("属性\n函数身上一定有"),a("code",[t._v("prototype")]),t._v("方法")]),t._v(" "),a("p",[t._v("实例的隐式原型属性永远指向自己缔造者的原型对象")]),t._v(" "),a("h2",{attrs:{id:"vue脚手架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue脚手架"}},[t._v("#")]),t._v(" vue脚手架")]),t._v(" "),a("p",[t._v("Vue脚手架是Vue官方提供的标准化开发工具（开发平台）")]),t._v(" "),a("p",[t._v("package-lock.json —— 用来锁库的版本，可以设置安装依赖或者库时的默认版本")]),t._v(" "),a("h2",{attrs:{id:"render"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render"}},[t._v("#")]),t._v(" render")]),t._v(" "),a("p",[t._v("如果使用import Vue from ‘vue’ 的方式引入vue ， 则默认要看vue的package.json中的module属性的值，该值指定了默认引入的是哪个js文件")]),t._v(" "),a("p",[t._v("vue中包含着两个东西\n第一个是核心 —— 生命周期这些\n第二个是模板解析器 —— 解析vm的模板-tempalte —— 占1/3\n所以这时就引入了开发依赖和全局依赖，模板解析器就要放入开发依赖，因为打包后不需要这个东西了")]),t._v(" "),a("ol",[a("li",[t._v("vue.js与vue.runtime.xxx.js的区别：\n(1).vue.js是完整版的Vue，包含：核心功能+模板解析器。\n(2).vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。")])]),t._v(" "),a("p",[t._v("2.因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用\nrender函数接收到的createElement函数去指定具体内容。")]),t._v(" "),a("h2",{attrs:{id:"ref属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ref属性"}},[t._v("#")]),t._v(" ref属性")]),t._v(" "),a("ol",[a("li",[t._v("被用来给元素或子组件注册引用信息（id的替代者）")]),t._v(" "),a("li",[t._v("应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）")]),t._v(" "),a("li",[t._v("使用方式：\n"),a("ol",[a("li",[t._v("打标识："),a("code",[t._v('<h1 ref="xxx">.....</h1>')]),t._v(" 或 "),a("code",[t._v('<School ref="xxx"></School>')])]),t._v(" "),a("li",[t._v("获取："),a("code",[t._v("this.$refs.xxx")])])])])]),t._v(" "),a("h2",{attrs:{id:"记录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#记录"}},[t._v("#")]),t._v(" 记录")]),t._v(" "),a("p",[t._v("数据没有更新 —— 看数据有没有设置为reactive")]),t._v(" "),a("p",[t._v("ref记得用value来访问")]),t._v(" "),a("p",[t._v("ref对象转为普通对象 —— torefs()")]),t._v(" "),a("p",[t._v("ref的字符串怎么转为普通字符串？ —— let data = JSON.parse(JSON.stringify(todos));")]),t._v(" "),a("p",[t._v("click事件优化 —— change事件")]),t._v(" "),a("p",[t._v("vue监测对象的修改是浅修改 —— 修改对象中的数据是监测不到的，直接修改对象本身才可以被发现")]),t._v(" "),a("p",[t._v("如果使用const定义的数据，那么删除的话就不要用filter，因为filter不会修改原数组中的内容，再给数据重新赋值的话是不允许的，因为是const —— 使用splice() —— splice(i, 1)删除i位置的一个元素")]),t._v(" "),a("p",[a("strong",[t._v("前端需要熟练掌握数组和对象身上的方法！！！")])]),t._v(" "),a("p",[t._v("使用v-model时要注意：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！！")]),t._v(" "),a("p",[t._v("把响应式数据转普通数据 —— let data = JSON.parse(JSON.stringify(todos));")]),t._v(" "),a("h2",{attrs:{id:"浏览器的本地存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的本地存储"}},[t._v("#")]),t._v(" 浏览器的本地存储")]),t._v(" "),a("p",[t._v("localStorage —— 关闭浏览器不会消失 —— 需要手动删除 调用api或清空缓存\nsessionStorage —— 浏览器关了就没有了")]),t._v(" "),a("p",[t._v("四个api")]),t._v(" "),a("ol",[a("li",[t._v("setItem —— 设置")]),t._v(" "),a("li",[t._v("getItem —— 读取 —— 如果传入的key没有的话是返回null，而不是undefined")]),t._v(" "),a("li",[t._v("removeItem —— 删除一个")]),t._v(" "),a("li",[t._v("clear —— 清除所有")])]),t._v(" "),a("p",[t._v("JSON.parse(null)的结果还是null")]),t._v(" "),a("h2",{attrs:{id:"watch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" watch")]),t._v(" "),a("p",[t._v("setup 里的 watch 完全等同于组件侦听器 property。watch 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调。")]),t._v(" "),a("p",[t._v("watch 的工作原理：侦听特定的数据源，并在回调函数中执行副作用。它默认是惰性的——只有当被侦听的源发生变化时才执行回调，不过，可以通过配置 immediate 为 true 来指定初始时立即执行第一次。可以通过配置 deep 为 true，来指定深度监视。")]),t._v(" "),a("p",[t._v("watch 的两个属性：")]),t._v(" "),a("p",[t._v("immdiate: 默认情况下，侦听器需要 data 后面值改变了才会生效，若需要侦听器一进入页面就生效，那就需要使用 immediate。")]),t._v(" "),a("p",[t._v("deep: 默认情况下，侦听器只会监听数据本身的改变，若要进行深度监听，那就需要使用 deep。\nimmediate 和 deep 配置在第三个参数对象里。")]),t._v(" "),a("h2",{attrs:{id:"绑定和解绑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#绑定和解绑"}},[t._v("#")]),t._v(" 绑定和解绑")]),t._v(" "),a("p",[t._v("自定义事件写到mounted里，可以实现异步需求")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mounted")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$refs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("student"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("$on")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'atguigu'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("getStudentName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//绑定自定义事件")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$refs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("student"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("$once")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'atguigu'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("getStudentName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//绑定自定义事件（一次性）")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])])]),a("p",[t._v("解绑自定义事件")]),t._v(" "),a("p",[a("code",[t._v('this.$off(["xx", "xxx"])')])]),t._v(" "),a("p",[t._v("@click.native —— 识别为原生的click事件，不会识别为自定义事件")]),t._v(" "),a("p",[t._v("事件的回调在父组件")]),t._v(" "),a("h2",{attrs:{id:"全局事件总线-一种经验"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局事件总线-一种经验"}},[t._v("#")]),t._v(" 全局事件总线——一种经验")]),t._v(" "),a("p",[t._v("任意组件间通信 —— 一个傀儡组件X —— $bus")]),t._v(" "),a("ol",[a("li",[t._v("保证所有组件都能看见X组件 —— 放在vue上")]),t._v(" "),a("li",[t._v("保证X可以调用$on, $off, $emits这些方法")])]),t._v(" "),a("p",[t._v("在所有组件中都可以给$bus绑定自定义事件，但要记得在组件的beforeDestroyed()解绑该组件给$bus配置的自定义事件")]),t._v(" "),a("h2",{attrs:{id:"消息订阅与发布"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息订阅与发布"}},[t._v("#")]),t._v(" 消息订阅与发布")]),t._v(" "),a("p",[t._v("借用第三方库 —— pubsub-js")]),t._v(" "),a("p",[a("strong",[t._v("一种组件间通信的方式，适用于任何组件间通信")])]),t._v(" "),a("p",[t._v("回调函数在订阅组件中 —— 谁需要获得数据就是订阅组件，就配置回调函数")]),t._v(" "),a("p",[t._v("两个button —— edit为false时，表示不是编辑状态，显示编辑\ntrue表示在编辑，显示保存按钮")]),t._v(" "),a("p",[t._v("点击button时，获取input上输入的数据？")]),t._v(" "),a("p",[t._v("拿到input数据之后，要调用父组件的修改title方法")]),t._v(" "),a("p",[t._v("修改了之后不能删除了 ——跟是否修改没关系 —— 是删除方法的原因")]),t._v(" "),a("p",[t._v("如果要重复处理数据 —— 不要用splice —— 用filter")]),t._v(" "),a("h2",{attrs:{id:"nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[t._v("#")]),t._v(" nextTick")]),t._v(" "),a("p",[t._v("vue看见nexttick，就会跳过里面的函数一次，等到这次DOM更新渲染结束之后，再执行里面的回调函数")]),t._v(" "),a("p",[t._v("执行里面的函数之前需要重新解析模板，这时就可以得到上边数据更新后的页面结果，然后执行里面的函数，再重新渲染页面")]),t._v(" "),a("p",[t._v("nextTick 是将回调推迟到下一个 DOM 更新周期之后执行。在更改了一些数据以等待 DOM 更新后立即使用它")]),t._v(" "),a("p",[t._v("什么时候用？")]),t._v(" "),a("p",[t._v("当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。")]),t._v(" "),a("h2",{attrs:{id:"transition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transition"}},[t._v("#")]),t._v(" transition")]),t._v(" "),a("p",[a("code",[t._v("<transition></transition>")])]),t._v(" "),a("p",[t._v("vue做了什么事呢？")]),t._v(" "),a("p",[t._v("如果你想显示一个组件，那就在显示之前播放你设置的动画 —— v-enter-active，你想隐藏一个组件，那就在隐藏之前播放你设置的动画 —— v-leave-active")]),t._v(" "),a("p",[t._v("animation —— 动画 —— 封装的也是动画")]),t._v(" "),a("p",[t._v("transfrom —— 转换过渡 —— 封装的就是过渡")]),t._v(" "),a("p",[t._v("一个元素来到页面的时候，vue一共给元素加上了三个样式的类名，进入的起点，进入的过程中，进入的终点，离开页面的时候也是类似的")]),t._v(" "),a("h2",{attrs:{id:"配置代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置代理"}},[t._v("#")]),t._v(" 配置代理")]),t._v(" "),a("p",[t._v("fetch存在两个问题")]),t._v(" "),a("ol",[a("li",[t._v("返回的数据包了两层promise")]),t._v(" "),a("li",[t._v("兼容性比较差 —— ie不支持")])]),t._v(" "),a("p",[t._v("跨域问题不是发不出去请求，而是发出请求了，同时服务器也接收到请求，返回数据了，是可换单拿不到数据 —— 浏览器发现请求这边是跨域，就不给这边了")]),t._v(" "),a("p",[t._v("jsonp利用了script标签的src，在引入外部资源的时候，不受同源策略限制的这个特点来实现的"),a("br"),t._v("\n在开发中几乎不用 —— 只能解决get请求，而且操作麻烦，前后端配合")]),t._v(" "),a("p",[t._v("利用"),a("code",[t._v("vue.config.js")]),t._v("配置"),a("code",[t._v("devServer")]),t._v("的"),a("code",[t._v('proxy: "string"')]),t._v("的方式的缺点如下")]),t._v(" "),a("ol",[a("li",[t._v("不能配置多个代理")]),t._v(" "),a("li",[t._v("不能灵活的控制是否通过代理服务器")])]),t._v(" "),a("p",[t._v("利用"),a("code",[t._v("vue.config.js")]),t._v("配置"),a("code",[t._v("devServer")]),t._v("的"),a("code",[t._v('proxy: "option"')]),t._v("的方式的缺点如下")]),t._v(" "),a("ol",[a("li",[t._v("配置略微繁琐，需要对请求头的前缀进行添加和去除的操作")])]),t._v(" "),a("h2",{attrs:{id:"作用域插槽"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域插槽"}},[t._v("#")]),t._v(" 作用域插槽")]),t._v(" "),a("p",[t._v("数据在组件的自身，但根据数据生成的结构需要组件的使用者来指定")]),t._v(" "),a("p",[t._v("template配置scope —— 可以读到插槽slot中的数据")]),t._v(" "),a("p",[a("strong",[t._v("作用域插槽的使用场景 —— 插槽的样式和结构根据使用者的需求来变化，数据在设置插槽的组件中，但是由数据生成的结构和样式是在使用的组件中设置的")])]),t._v(" "),a("h2",{attrs:{id:"vuex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[t._v("#")]),t._v(" vuex")]),t._v(" "),a("p",[t._v("Actions"),a("br"),t._v("\nMutations\nstate\n这些都是对象 —— pinia中的state是一个函数")]),t._v(" "),a("p",[t._v("模板里面能看到vc中的所有内容")]),t._v(" "),a("p",[t._v("Action里写业务逻辑，比如ajax请求这些 —— 服务员")]),t._v(" "),a("p",[t._v("mutation里只写方法，不要再写逻辑处理 —— 厨师")]),t._v(" "),a("p",[t._v("不要在action中操作state")]),t._v(" "),a("p",[t._v("如果逻辑需要复用的话，可以把逻辑写到getter中")]),t._v(" "),a("p",[t._v("vuex中一些便于我们使用的函数 —— vuex已经给我们封装好了\nmapState"),a("br"),t._v("\nmapGetters"),a("br"),t._v("\nmapMutations"),a("br"),t._v("\nmapActions")]),t._v(" "),a("p",[t._v("vuex的模块化编码 —— 管理多个不同的store")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vuex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Store")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("modules")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\txxx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\txxx\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h2",{attrs:{id:"路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由"}},[t._v("#")]),t._v(" 路由")]),t._v(" "),a("p",[t._v("就是一种对应关系")]),t._v(" "),a("p",[t._v("key1 + value1 = 路由")]),t._v(" "),a("p",[t._v("多个路由被路由器所管理")]),t._v(" "),a("p",[t._v("key —— 就是路径，value —— 就是组件内容，一组key-value就是一个路由")]),t._v(" "),a("p",[t._v("数据需要通过ajax来获取")]),t._v(" "),a("p",[t._v("路由切换 —— 组件切换是先把之前显示的组件"),a("strong",[t._v("销毁")]),t._v("，再"),a("strong",[t._v("挂载")]),t._v("将要显示的组件")]),t._v(" "),a("p",[a("strong",[t._v("路由的两种工作模式")])]),t._v(" "),a("ol",[a("li",[a("code",[t._v("/#/")])])]),t._v(" "),a("p",[t._v("路由的关键 —— 定义规则")]),t._v(" "),a("p",[t._v("点击完导航区，路由怎么跳转，路由中的数据怎么变")]),t._v(" "),a("p",[t._v("可以带参数 —— query参数 —— 尽量使用对象形式")]),t._v(" "),a("p",[t._v("如果使用"),a("code",[t._v("params")]),t._v("参数，那就需要在路由"),a("code",[t._v("js")]),t._v("文件中声明接收"),a("code",[t._v("params")]),t._v("参数")]),t._v(" "),a("p",[a("code",[t._v('path : "/xxx/:id/:title"')]),t._v(" —— 使用占位符来声明接收"),a("code",[t._v("params")]),t._v("参数")]),t._v(" "),a("p",[t._v("解构赋值可以嵌套使用，比如下面")]),t._v(" "),a("p",[a("code",[t._v("{query: {id, title}}")]),t._v("\n先解构出"),a("code",[t._v("query")]),t._v("，再解构出"),a("code",[t._v("query")]),t._v("里的"),a("code",[t._v("id")]),t._v("和"),a("code",[t._v("title")])]),t._v(" "),a("p",[t._v("路由的props仨种写法")]),t._v(" "),a("ol",[a("li",[t._v("对象 —— 这样写是死数据")]),t._v(" "),a("li",[t._v("布尔值 —— params")]),t._v(" "),a("li",[t._v("函数 —— 把$route.query作为参数传进去")])]),t._v(" "),a("p",[t._v("浏览器历史记录有两种模式 —— push 和 replace")]),t._v(" "),a("p",[t._v("push是追加， replace是替换当前记录")]),t._v(" "),a("h3",{attrs:{id:"缓存路由组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存路由组件"}},[t._v("#")]),t._v(" 缓存路由组件")]),t._v(" "),a("p",[t._v("keep-alive组件")]),t._v(" "),a("h2",{attrs:{id:"路由守卫"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由守卫"}},[t._v("#")]),t._v(" 路由守卫")]),t._v(" "),a("p",[t._v("全局前置守卫和全局后置守卫 —— 路由切换前一定会走这里，刚进入页面也会走 —— 可以在这里加权限")]),t._v(" "),a("p",[t._v("独享路由守卫 —— 在路由规则中设置，此时还未通过路由规则")]),t._v(" "),a("p",[t._v("组件内路由守卫 —— 通过路由规则（比如点击router-link），"),a("strong",[t._v("进入")]),t._v("或"),a("strong",[t._v("离开")]),t._v("该组件时被调用\n场景： 组件内想写一些该组件特有的逻辑时")]),t._v(" "),a("h2",{attrs:{id:"路由器的两种工作模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由器的两种工作模式"}},[t._v("#")]),t._v(" 路由器的两种工作模式")]),t._v(" "),a("p",[t._v("对于一个url来说，什么是hash值？ —— #及其后面的内容就是hash值")]),t._v(" "),a("p",[t._v("hash值不会包含在HTTP请求中，即：hash值不会带给服务器")]),t._v(" "),a("h3",{attrs:{id:"hash模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash模式"}},[t._v("#")]),t._v(" hash模式")]),t._v(" "),a("ol",[a("li",[t._v("地址中永远带着#号，不美观")]),t._v(" "),a("li",[t._v("若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法")]),t._v(" "),a("li",[t._v("兼容性较好")])]),t._v(" "),a("h3",{attrs:{id:"history模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history模式"}},[t._v("#")]),t._v(" history模式")]),t._v(" "),a("ol",[a("li",[t._v("地址干净，美观")]),t._v(" "),a("li",[t._v("兼容性和hash模式相比略差")]),t._v(" "),a("li",[t._v("应用部署上线时需要后端人员支持，解决刷新页面404的问题")])]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v('const history = require("connect-history-api-fallback");')]),t._v(" "),a("code",[t._v("app.use(history());")])])]),t._v(" "),a("h2",{attrs:{id:"按需引入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#按需引入"}},[t._v("#")]),t._v(" 按需引入")]),t._v(" "),a("p",[t._v("babel.config.js 配置")]),t._v(" "),a("h2",{attrs:{id:"vite-创建-vue3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vite-创建-vue3"}},[t._v("#")]),t._v(" vite 创建 vue3")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("npm init vite-app <your project-name>  // 创建工程\ncd <your project-name>\t// 进入工程目录\nyarn\t// 安装依赖\nyarn dev  // 启动项目\n")])])]),a("h2",{attrs:{id:"vue3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3"}},[t._v("#")]),t._v(" vue3")]),t._v(" "),a("p",[t._v("如果一个函数被"),a("code",[t._v("async")]),t._v("修饰了，那么他的返回值会被一层"),a("code",[t._v("Promise")]),t._v("给封装")]),t._v(" "),a("p",[t._v("vue3的生命周期函数")]),t._v(" "),a("h3",{attrs:{id:"toref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#toref"}},[t._v("#")]),t._v(" toRef")]),t._v(" "),a("p",[t._v("toRef(param1, param2)")]),t._v(" "),a("ul",[a("li",[t._v("第一个参数 —— 你想操作哪个对象")]),t._v(" "),a("li",[t._v("第二个参数 —— 你想要对象中的哪个属性")])]),t._v(" "),a("p",[t._v("作用： 创建一个ref对象，其value值指向另一个对象的某个属性")]),t._v(" "),a("p",[t._v("场景： 要将响应式对象中的某个属性单独提供给外部使用时")]),t._v(" "),a("p",[t._v("toRefs与toRef功能一致，但toRefs可以批量创建多个ref对象，语法: toRefs(person)")]),t._v(" "),a("h3",{attrs:{id:"shallowreactive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shallowreactive"}},[t._v("#")]),t._v(" shallowReactive")]),t._v(" "),a("p",[t._v("只处理对象最外层属性的响应式（浅响应式）\n场景： 如果有一个对象数据，结构比较深，但变化时只是外层属性变化 —— shallowReactive")]),t._v(" "),a("h3",{attrs:{id:"shallowref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shallowref"}},[t._v("#")]),t._v(" shallowRef")]),t._v(" "),a("p",[t._v("只处理基本数据类型响应式，不再处理对象类型的响应式 —— 除非你直接替换当前对象 —— 第一层"),a("br"),t._v("\n场景：如果有一个对象数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换 —— shallowRef")]),t._v(" "),a("p",[a("strong",[t._v("场景 —— 不希望数据被修改时")]),t._v(" 👇")]),t._v(" "),a("h3",{attrs:{id:"readonly"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#readonly"}},[t._v("#")]),t._v(" readonly")]),t._v(" "),a("p",[t._v("让一个响应式数据变为只读的（深只读）")]),t._v(" "),a("h3",{attrs:{id:"shallowreadonly"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shallowreadonly"}},[t._v("#")]),t._v(" shallowReadonly")]),t._v(" "),a("p",[t._v("让一个响应式数据变为只读的（浅只读）")]),t._v(" "),a("h3",{attrs:{id:"toraw"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#toraw"}},[t._v("#")]),t._v(" toRaw")]),t._v(" "),a("p",[t._v("不能用于ref，只能用于reactive")]),t._v(" "),a("p",[t._v("作用：将一个由reactive生成的响应式对象转为普通对象")]),t._v(" "),a("p",[t._v("场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新")]),t._v(" "),a("h3",{attrs:{id:"markraw"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#markraw"}},[t._v("#")]),t._v(" markRaw")]),t._v(" "),a("p",[t._v("作用：标记一个对象，使其永远不会再成为响应式对象")]),t._v(" "),a("p",[t._v("场景：")]),t._v(" "),a("ol",[a("li",[t._v("有些值不应被设置为响应式的，例如复杂的第三方类库等")]),t._v(" "),a("li",[t._v("当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能")])]),t._v(" "),a("h3",{attrs:{id:"optionsapi-vs-compositonapi"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#optionsapi-vs-compositonapi"}},[t._v("#")]),t._v(" OptionsAPI VS CompositonAPI")]),t._v(" "),a("ul",[a("li",[t._v("新增或者修改一个需求，就需要分别在data, computed, methods里修改")]),t._v(" "),a("li",[t._v("组合式API让我们可以更加优雅的组织我们的代码，函数，让相关功能的代码更加有序的组织在一起 —— 通过hook")])]),t._v(" "),a("h3",{attrs:{id:"teleport"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#teleport"}},[t._v("#")]),t._v(" Teleport")]),t._v(" "),a("p",[t._v('Teleport to= "xxx" —— 把组件扔到xxx位置来渲染')]),t._v(" "),a("h3",{attrs:{id:"suspense"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#suspense"}},[t._v("#")]),t._v(" Suspense")]),t._v(" "),a("p",[t._v("等待异步组件时渲染一些额外内容，让用户有更好的用户体验")]),t._v(" "),a("p",[t._v("使用步骤：")]),t._v(" "),a("ol",[a("li",[t._v("异步引入组件")])]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" defineAsyncComponent "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"vue"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Demo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("defineAsyncComponent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./components/Demo.vue"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v("使用Suspense包裹组件，并配置好default —— （要显示的内容，但是是异步才会显示）和fallback（default显示之前，想要在default位置呈现的内容）")])]),t._v(" "),a("div",{staticClass:"language-vue extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[t._v("\t\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Suspense")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("v-slot:")]),t._v("default")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Demo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("template")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("v-slot:")]),t._v("fallback")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("h3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("稍等，加载中..."),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("h3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("template")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Suspense")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);